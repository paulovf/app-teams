(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.OfficeHelpers = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license.
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
    return { next: verb(0), "throw": verb(1), "return": verb(2) };
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var endpoint_manager_1 = require("./endpoint.manager");
var token_manager_1 = require("./token.manager");
var utilities_1 = require("../helpers/utilities");
var dialog_1 = require("../helpers/dialog");
var auth_1 = require("../errors/auth");
/**
 * Helper for performing Implicit OAuth Authentication with registered endpoints.
 */
var Authenticator = (function () {
    /**
     * @constructor
     *
     * @param endpointManager Depends on an instance of EndpointManager.
     * @param TokenManager Depends on an instance of TokenManager.
    */
    function Authenticator(endpoints, tokens) {
        this.endpoints = endpoints;
        this.tokens = tokens;
        if (endpoints == null) {
            this.endpoints = new endpoint_manager_1.EndpointManager();
        }
        if (tokens == null) {
            this.tokens = new token_manager_1.TokenManager();
        }
    }
    /**
     * Authenticate based on the given provider.
     * Either uses DialogAPI or Window Popups based on where its being called from either Add-in or Web.
     * If the token was cached, the it retrieves the cached token.
     * If the cached token has expired then the authentication dialog is displayed.
     *
     * NOTE: you have to manually check the expires_in or expires_at property to determine
     * if the token has expired. Not all OAuth providers support refresh token flows.
     *
     * @param {string} provider Link to the provider.
     * @param {boolean} force Force re-authentication.
     * @return {Promise<IToken|ICode>} Returns a promise of the token or code or error.
     */
    Authenticator.prototype.authenticate = function (provider, force, useMicrosoftTeams) {
        if (force === void 0) { force = false; }
        if (useMicrosoftTeams === void 0) { useMicrosoftTeams = false; }
        var token = this.tokens.get(provider);
        var hasTokenExpired = token_manager_1.TokenManager.hasExpired(token);
        if (!hasTokenExpired && !force) {
            return Promise.resolve(token);
        }
        if (useMicrosoftTeams) {
            return this._openAuthDialog(provider, true);
        }
        else if (utilities_1.Utilities.isAddin) {
            return this._openAuthDialog(provider, false);
        }
        else {
            return this._openInWindowPopup(provider);
        }
    };
    /**
     * Check if the currrent url is running inside of a Dialog that contains an access_token or code or error.
     * If true then it calls messageParent by extracting the token information, thereby closing the dialog.
     * Otherwise, the caller should proceed with normal initialization of their application.
     *
     * @return {boolean}
     * Returns false if the code is running inside of a dialog without the required information
     * or is not running inside of a dialog at all.
     */
    Authenticator.isAuthDialog = function (useMicrosoftTeams) {
        if (useMicrosoftTeams === void 0) { useMicrosoftTeams = false; }
        if (useMicrosoftTeams === false && !utilities_1.Utilities.isAddin) {
            return false;
        }
        else {
            if (!/(access_token|code|error)/gi.test(location.href)) {
                return false;
            }
            dialog_1.Dialog.close(location.href, useMicrosoftTeams);
            return true;
        }
    };
    Authenticator.prototype._openAuthDialog = function (provider, useMicrosoftTeams) {
        return __awaiter(this, void 0, void 0, function () {
            var endpoint, _a, state, url, redirectUrl;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        endpoint = this.endpoints.get(provider);
                        if (endpoint == null) {
                            return [2 /*return*/, Promise.reject(new auth_1.AuthError("No such registered endpoint: " + provider + " could be found."))];
                        }
                        _a = endpoint_manager_1.EndpointManager.getLoginParams(endpoint), state = _a.state, url = _a.url;
                        return [4 /*yield*/, new dialog_1.Dialog(url, 1024, 768, useMicrosoftTeams).result];
                    case 1:
                        redirectUrl = _b.sent();
                        /** Try and extract the result and pass it along */
                        return [2 /*return*/, this._handleTokenResult(redirectUrl, endpoint, state)];
                }
            });
        });
    };
    Authenticator.prototype._openInWindowPopup = function (provider) {
        var _this = this;
        /** Get the endpoint configuration for the given provider and verify that it exists. */
        var endpoint = this.endpoints.get(provider);
        if (endpoint == null) {
            return Promise.reject(new auth_1.AuthError("No such registered endpoint: " + provider + " could be found."));
        }
        var _a = endpoint_manager_1.EndpointManager.getLoginParams(endpoint), state = _a.state, url = _a.url;
        var windowFeatures = "width=" + 1024 + ",height=" + 768 + ",menubar=no,toolbar=no,location=no,resizable=yes,scrollbars=yes,status=no";
        var popupWindow = window.open(url, endpoint.provider.toUpperCase(), windowFeatures);
        return new Promise(function (resolve, reject) {
            try {
                var POLL_INTERVAL = 400;
                var interval_1 = setInterval(function () {
                    try {
                        if (popupWindow.document.URL.indexOf(endpoint.redirectUrl) !== -1) {
                            clearInterval(interval_1);
                            popupWindow.close();
                            return resolve(_this._handleTokenResult(popupWindow.document.URL, endpoint, state));
                        }
                    }
                    catch (exception) {
                        if (!popupWindow) {
                            clearInterval(interval_1);
                            return reject(new auth_1.AuthError('Popup window was closed'));
                        }
                    }
                }, POLL_INTERVAL);
            }
            catch (exception) {
                popupWindow.close();
                return reject(new auth_1.AuthError('Unexpected error occured while creating popup'));
            }
        });
    };
    /**
     * Helper for exchanging the code with a registered Endpoint.
     * The helper sends a POST request to the given Endpoint's tokenUrl.
     *
     * The Endpoint must accept the data JSON input and return an 'access_token'
     * in the JSON output.
     *
     * @param {Endpoint} endpoint Endpoint configuration.
     * @param {object} data Data to be sent to the tokenUrl.
     * @param {object} headers Headers to be sent to the tokenUrl.     *
     * @return {Promise<IToken>} Returns a promise of the token or error.
     */
    Authenticator.prototype._exchangeCodeForToken = function (endpoint, data, headers) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            if (endpoint.tokenUrl == null) {
                console.warn("We couldn't exchange the received code for an access_token.\n                    The value returned is not an access_token.\n                    Please set the tokenUrl property or refer to our docs.");
                return resolve(data);
            }
            var xhr = new XMLHttpRequest();
            xhr.open('POST', endpoint.tokenUrl);
            xhr.setRequestHeader('Accept', 'application/json');
            xhr.setRequestHeader('Content-Type', 'application/json');
            for (var header in headers) {
                if (header === 'Accept' || header === 'Content-Type') {
                    continue;
                }
                xhr.setRequestHeader(header, headers[header]);
            }
            xhr.onerror = function () {
                return reject(new auth_1.AuthError('Unable to send request due to a Network error'));
            };
            xhr.onload = function () {
                try {
                    if (xhr.status === 200) {
                        var json = JSON.parse(xhr.responseText);
                        if (json == null) {
                            return reject(new auth_1.AuthError('No access_token or code could be parsed.'));
                        }
                        else if ('access_token' in json) {
                            _this.tokens.add(endpoint.provider, json);
                            return resolve(json);
                        }
                        else {
                            return reject(new auth_1.AuthError(json.error, json.state));
                        }
                    }
                    else if (xhr.status !== 200) {
                        return reject(new auth_1.AuthError('Request failed. ' + xhr.response));
                    }
                }
                catch (e) {
                    return reject(new auth_1.AuthError('An error occured while parsing the response'));
                }
            };
            xhr.send(JSON.stringify(data));
        });
    };
    /**
     * Extract the token from the URL
     *
     * @param {string} url The url to extract the token from.
     * @param {string} exclude Exclude a particlaur string from the url, such as a query param or specific substring.
     * @param {string} delimiter[optional] Delimiter used by OAuth provider to mark the beginning of token response. Defaults to #.
     * @return {object} Returns the extracted token.
     */
    Authenticator.prototype._getToken = function (url, exclude, delimiter) {
        if (url === void 0) { url = location.href; }
        if (exclude === void 0) { exclude = location.origin; }
        if (delimiter === void 0) { delimiter = '#'; }
        if (exclude) {
            url = url.replace(exclude, '');
        }
        var _a = url.split(delimiter), left = _a[0], right = _a[1];
        var tokenString = right == null ? left : right;
        if (tokenString.indexOf('?') !== -1) {
            var _b = tokenString.split('?'), ignore = _b[0], queryPart = _b[1];
            tokenString = queryPart;
        }
        return this._extractParams(tokenString);
    };
    Authenticator.prototype._extractParams = function (segment) {
        if (segment == null || segment.trim() == '') {
            return null;
        }
        var params = {}, regex = /([^&=]+)=([^&]*)/g, matches;
        while ((matches = regex.exec(segment)) !== null) {
            params[decodeURIComponent(matches[1])] = decodeURIComponent(matches[2]);
        }
        return params;
    };
    Authenticator.prototype._handleTokenResult = function (redirectUrl, endpoint, state) {
        var result = this._getToken(redirectUrl, endpoint.redirectUrl);
        if (result == null) {
            throw new auth_1.AuthError('No access_token or code could be parsed.');
        }
        else if (endpoint.state && +result.state !== state) {
            throw new auth_1.AuthError('State couldn\'t be verified');
        }
        else if ('code' in result) {
            return this._exchangeCodeForToken(endpoint, result);
        }
        else if ('access_token' in result) {
            return this.tokens.add(endpoint.provider, result);
        }
        else {
            throw new auth_1.AuthError(result.error, result.state);
        }
    };
    return Authenticator;
}());
exports.Authenticator = Authenticator;

},{"../errors/auth":4,"../helpers/dialog":6,"../helpers/utilities":9,"./endpoint.manager":2,"./token.manager":3}],2:[function(require,module,exports){
// Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var utilities_1 = require("../helpers/utilities");
var storage_1 = require("../helpers/storage");
exports.DefaultEndpoints = {
    Google: 'Google',
    Microsoft: 'Microsoft',
    Facebook: 'Facebook',
    AzureAD: 'AzureAD'
};
/**
 * Helper for creating and registering OAuth Endpoints.
 */
var EndpointManager = (function (_super) {
    __extends(EndpointManager, _super);
    /**
     * @constructor
    */
    function EndpointManager() {
        return _super.call(this, 'OAuth2Endpoints', storage_1.StorageType.LocalStorage) || this;
    }
    /**
     * Extends Storage's default add method.
     * Registers a new OAuth Endpoint.
     *
     * @param {string} provider Unique name for the registered OAuth Endpoint.
     * @param {object} config Valid Endpoint configuration.
     * @see {@link IEndpoint}.
     * @return {object} Returns the added endpoint.
     */
    EndpointManager.prototype.add = function (provider, config) {
        if (config.redirectUrl == null) {
            config.redirectUrl = window.location.origin;
        }
        config.provider = provider;
        return _super.prototype.insert.call(this, provider, config);
    };
    /**
     * Register Google Implicit OAuth.
     * If overrides is left empty, the default scope is limited to basic profile information.
     *
     * @param {string} clientId ClientID for the Google App.
     * @param {object} config Valid Endpoint configuration to override the defaults.
     * @return {object} Returns the added endpoint.
     */
    EndpointManager.prototype.registerGoogleAuth = function (clientId, overrides) {
        var defaults = {
            clientId: clientId,
            baseUrl: 'https://accounts.google.com',
            authorizeUrl: '/o/oauth2/v2/auth',
            resource: 'https://www.googleapis.com',
            responseType: 'token',
            scope: 'https://www.googleapis.com/auth/plus.me',
            state: true
        };
        var config = utilities_1.Utilities.extend({}, overrides, defaults);
        return this.add(exports.DefaultEndpoints.Google, config);
    };
    ;
    /**
     * Register Microsoft Implicit OAuth.
     * If overrides is left empty, the default scope is limited to basic profile information.
     *
     * @param {string} clientId ClientID for the Microsoft App.
     * @param {object} config Valid Endpoint configuration to override the defaults.
     * @return {object} Returns the added endpoint.
     */
    EndpointManager.prototype.registerMicrosoftAuth = function (clientId, overrides) {
        var defaults = {
            clientId: clientId,
            baseUrl: 'https://login.microsoftonline.com/common/oauth2/v2.0',
            authorizeUrl: '/authorize',
            responseType: 'token',
            scope: 'https://graph.microsoft.com/user.read',
            extraParameters: '&response_mode=fragment',
            nonce: true,
            state: true
        };
        var config = utilities_1.Utilities.extend({}, overrides, defaults);
        this.add(exports.DefaultEndpoints.Microsoft, config);
    };
    ;
    /**
     * Register Facebook Implicit OAuth.
     * If overrides is left empty, the default scope is limited to basic profile information.
     *
     * @param {string} clientId ClientID for the Facebook App.
     * @param {object} config Valid Endpoint configuration to override the defaults.
     * @return {object} Returns the added endpoint.
     */
    EndpointManager.prototype.registerFacebookAuth = function (clientId, overrides) {
        var defaults = {
            clientId: clientId,
            baseUrl: 'https://www.facebook.com',
            authorizeUrl: '/dialog/oauth',
            resource: 'https://graph.facebook.com',
            responseType: 'token',
            scope: 'public_profile',
            nonce: true,
            state: true
        };
        var config = utilities_1.Utilities.extend({}, overrides, defaults);
        this.add(exports.DefaultEndpoints.Facebook, config);
    };
    ;
    /**
     * Register AzureAD Implicit OAuth.
     * If overrides is left empty, the default scope is limited to basic profile information.
     *
     * @param {string} clientId ClientID for the AzureAD App.
     * @param {string} tenant Tenant for the AzureAD App.
     * @param {object} config Valid Endpoint configuration to override the defaults.
     * @return {object} Returns the added endpoint.
     */
    EndpointManager.prototype.registerAzureADAuth = function (clientId, tenant, overrides) {
        var defaults = {
            clientId: clientId,
            baseUrl: "https://login.windows.net/" + tenant,
            authorizeUrl: '/oauth2/authorize',
            resource: 'https://graph.microsoft.com',
            responseType: 'token',
            nonce: true,
            state: true
        };
        var config = utilities_1.Utilities.extend({}, overrides, defaults);
        this.add(exports.DefaultEndpoints.AzureAD, config);
    };
    ;
    /**
     * Helper to generate the OAuth login url.
     *
     * @param {object} config Valid Endpoint configuration.
     * @return {object} Returns the added endpoint.
     */
    EndpointManager.getLoginParams = function (endpointConfig) {
        var scope = (endpointConfig.scope) ? encodeURIComponent(endpointConfig.scope) : null;
        var resource = (endpointConfig.resource) ? encodeURIComponent(endpointConfig.resource) : null;
        var state = endpointConfig.state && EndpointManager.generateCryptoSafeRandom();
        var nonce = endpointConfig.nonce && EndpointManager.generateCryptoSafeRandom();
        var urlSegments = [
            'response_type=' + endpointConfig.responseType,
            'client_id=' + encodeURIComponent(endpointConfig.clientId),
            'redirect_uri=' + encodeURIComponent(endpointConfig.redirectUrl)
        ];
        if (scope) {
            urlSegments.push('scope=' + scope);
        }
        if (resource) {
            urlSegments.push('resource=' + resource);
        }
        if (state) {
            urlSegments.push('state=' + state);
        }
        if (nonce) {
            urlSegments.push('nonce=' + nonce);
        }
        if (endpointConfig.extraQueryParameters) {
            urlSegments.push(endpointConfig.extraQueryParameters);
        }
        return {
            url: endpointConfig.baseUrl + endpointConfig.authorizeUrl + '?' + urlSegments.join('&'),
            state: state
        };
    };
    EndpointManager.generateCryptoSafeRandom = function () {
        var random = new Uint32Array(1);
        if ('msCrypto' in window) {
            window.msCrypto.getRandomValues(random);
        }
        else if ('crypto' in window) {
            window.crypto.getRandomValues(random);
        }
        else {
            throw new Error('The platform doesn\'t support generation of Cryptographically Safe Randoms. Please disable the state flag and try again');
        }
        return random[0];
    };
    return EndpointManager;
}(storage_1.Storage));
exports.EndpointManager = EndpointManager;

},{"../helpers/storage":8,"../helpers/utilities":9}],3:[function(require,module,exports){
// Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var storage_1 = require("../helpers/storage");
/**
 * Helper for caching and managing OAuth Tokens.
 */
var TokenManager = (function (_super) {
    __extends(TokenManager, _super);
    /**
     * @constructor
    */
    function TokenManager() {
        return _super.call(this, 'OAuth2Tokens', storage_1.StorageType.LocalStorage) || this;
    }
    /**
     * Compute the expiration date based on the expires_in field in a OAuth token.
     */
    TokenManager.setExpiry = function (token) {
        var expire = function (seconds) { return seconds == null ? null : new Date(new Date().getTime() + ~~seconds * 1000); };
        if (!(token == null) && token.expires_at == null) {
            token.expires_at = expire(token.expires_in);
        }
    };
    /**
     * Check if an OAuth token has expired.
     */
    TokenManager.hasExpired = function (token) {
        if (token == null) {
            return true;
        }
        if (token.expires_at == null) {
            return false;
        }
        else {
            token.expires_at = token.expires_at instanceof Date ? token.expires_at : new Date(token.expires_at);
            return token.expires_at.getTime() - new Date().getTime() < 0;
        }
    };
    /**
     * Extends Storage's default get method
     * Gets an OAuth Token after checking its expiry
     *
     * @param {string} provider Unique name of the corresponding OAuth Token.
     * @return {object} Returns the token or null if its either expired or doesn't exist.
     */
    TokenManager.prototype.get = function (provider) {
        var token = _super.prototype.get.call(this, provider);
        if (token == null) {
            return token;
        }
        var expired = TokenManager.hasExpired(token);
        if (expired) {
            _super.prototype.remove.call(this, provider);
            return null;
        }
        else {
            return token;
        }
    };
    /**
     * Extends Storage's default add method
     * Adds a new OAuth Token after settings its expiry
     *
     * @param {string} provider Unique name of the corresponding OAuth Token.
     * @param {object} config valid Token
     * @see {@link IToken}.
     * @return {object} Returns the added token.
     */
    TokenManager.prototype.add = function (provider, value) {
        value.provider = provider;
        TokenManager.setExpiry(value);
        return _super.prototype.insert.call(this, provider, value);
    };
    return TokenManager;
}(storage_1.Storage));
exports.TokenManager = TokenManager;

},{"../helpers/storage":8}],4:[function(require,module,exports){
/**
 * Custom error type to handle OAuth specific errors.
 */
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AuthError = (function (_super) {
    __extends(AuthError, _super);
    /**
     * @constructor
     *
     * @param message Error message to be propagated.
     * @param state OAuth state if available.
    */
    function AuthError(message, state) {
        var _this = _super.call(this, message) || this;
        _this.state = state;
        _this.name = 'AuthError';
        _this.message = message;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _this.constructor);
        }
        else {
            var error = new Error();
            if (error.stack) {
                var last_part = error.stack.match(/[^\s]+$/);
                _this.stack = _this.name + " at " + last_part;
            }
        }
        return _this;
    }
    return AuthError;
}(Error));
exports.AuthError = AuthError;

},{}],5:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var DialogError = (function (_super) {
    __extends(DialogError, _super);
    /**
     * @constructor
     *
     * @param message Error message to be propagated.
     * @param state OAuth state if available.
    */
    function DialogError(message, innerError) {
        var _this = _super.call(this, message) || this;
        _this.innerError = innerError;
        _this.name = 'DialogError';
        _this.message = message;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, _this.constructor);
        }
        else {
            var error = new Error();
            if (error.stack) {
                var last_part = error.stack.match(/[^\s]+$/);
                _this.stack = _this.name + " at " + last_part;
            }
        }
        return _this;
    }
    return DialogError;
}(Error));
exports.DialogError = DialogError;

},{}],6:[function(require,module,exports){
/* Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license. See LICENSE in the project root for license information. */
"use strict";
var utilities_1 = require("./utilities");
var dialog_1 = require("../errors/dialog");
var Dialog = (function () {
    /**
     * @constructor
     *
     * @param url Url to be opened in the dialog.
     * @param width Width of the dialog.
     * @param height Height of the dialog.
    */
    function Dialog(url, width, height, useTeamsDialog) {
        if (url === void 0) { url = location.origin; }
        if (width === void 0) { width = 1024; }
        if (height === void 0) { height = 768; }
        if (useTeamsDialog === void 0) { useTeamsDialog = false; }
        this.url = url;
        this.width = width;
        this.height = height;
        this.useTeamsDialog = useTeamsDialog;
        if (!(/^https/.test(url))) {
            throw new dialog_1.DialogError('URL has to be loaded over HTTPS.');
        }
        this.size = this._optimizeSize(width, height);
    }
    Object.defineProperty(Dialog.prototype, "result", {
        get: function () {
            if (this._result == null) {
                this._result = this.useTeamsDialog ? this._teamsDialog() : this._addinDialog();
            }
            return this._result;
        },
        enumerable: true,
        configurable: true
    });
    Dialog.prototype._addinDialog = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            Office.context.ui.displayDialogAsync(_this.url, { width: _this.size.width$, height: _this.size.height$ }, function (result) {
                if (result.status === Office.AsyncResultStatus.Failed) {
                    throw new dialog_1.DialogError(result.error.message);
                }
                else {
                    var dialog_2 = result.value;
                    dialog_2.addEventHandler(Office.EventType.DialogMessageReceived, function (args) {
                        try {
                            var result_1 = _this._safeParse(args.message);
                            if (result_1.parse) {
                                resolve(_this._safeParse(result_1.value));
                            }
                            else {
                                resolve(result_1.value);
                            }
                        }
                        catch (exception) {
                            reject(new dialog_1.DialogError('An unexpected error in the dialog has occured.', exception));
                        }
                        finally {
                            dialog_2.close();
                        }
                    });
                    dialog_2.addEventHandler(Office.EventType.DialogEventReceived, function (args) {
                        try {
                            reject(new dialog_1.DialogError(args.message, args.error));
                        }
                        catch (exception) {
                            reject(new dialog_1.DialogError('An unexpected error in the dialog has occured.', exception));
                        }
                        finally {
                            dialog_2.close();
                        }
                    });
                }
            });
        });
    };
    Dialog.prototype._teamsDialog = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            try {
                microsoftTeams.initialize();
            }
            catch (e) {
            }
            microsoftTeams.authentication.authenticate({
                url: _this.url,
                width: _this.size.width,
                height: _this.size.height,
                failureCallback: function (exception) { return reject(new dialog_1.DialogError('Error while launching dialog', exception)); },
                successCallback: function (message) { return resolve(message); }
            });
        });
    };
    /**
     * Close any open dialog by providing an optional message.
     * If more than one dialogs are attempted to be opened
     * an expcetion will be created.
     */
    Dialog.close = function (message, useTeamsDialog) {
        if (useTeamsDialog === void 0) { useTeamsDialog = false; }
        var parse = false;
        var value = message;
        if ((!(value == null)) && typeof value === 'object') {
            parse = true;
            value = JSON.stringify(value);
        }
        else if (typeof message === 'function') {
            throw new dialog_1.DialogError('Invalid message. Canno\'t pass functions as arguments');
        }
        try {
            if (useTeamsDialog) {
                try {
                    microsoftTeams.initialize();
                }
                catch (e) {
                }
                microsoftTeams.authentication.notifySuccess(JSON.stringify({ parse: parse, value: value }));
            }
            else if (utilities_1.Utilities.isAddin) {
                Office.context.ui.messageParent(JSON.stringify({ parse: parse, value: value }));
            }
        }
        catch (error) {
            throw new dialog_1.DialogError('Canno\'t close dialog', error);
        }
    };
    Dialog.prototype._getSize = function (width, height) {
        var screenWidth = window.screen.width;
        if (width && height) {
            return this._optimizeSize(width, height);
        }
        else if (screenWidth <= 640) {
            return this._optimizeSize(640, 480);
        }
        else if (screenWidth <= 1366) {
            return this._optimizeSize(1024, 768);
        }
        else if (screenWidth <= 1920) {
            return this._optimizeSize(1600, 900);
        }
    };
    Dialog.prototype._optimizeSize = function (width, height) {
        var screenWidth = window.screen.width;
        var screenHeight = window.screen.height;
        var optimizedWidth = this._maxSize(width, screenWidth);
        var optimizedHeight = this._maxSize(height, screenHeight);
        return {
            width$: this._percentage(optimizedWidth, screenWidth),
            height$: this._percentage(optimizedHeight, screenHeight),
            width: optimizedWidth,
            height: optimizedHeight
        };
    };
    Dialog.prototype._maxSize = function (value, max) {
        return value < (max - 30) ? value : max - 30;
    };
    ;
    Dialog.prototype._percentage = function (value, max) {
        return (value * 100 / max);
    };
    Dialog.prototype._safeParse = function (data) {
        try {
            var result = JSON.parse(data);
            return result;
        }
        catch (e) {
            return data;
        }
    };
    return Dialog;
}());
exports.Dialog = Dialog;

},{"../errors/dialog":5,"./utilities":9}],7:[function(require,module,exports){
// Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license.
"use strict";
/**
 * Helper for creating and querying Dictionaries.
 * A rudimentary alternative to ES6 Maps.
 */
var Dictionary = (function () {
    /**
     * @constructor
     * @param {object} items Initial seed of items.
    */
    function Dictionary(items) {
        this.items = items;
        if (!(this.items === new Object(this.items)) || Array.isArray(this.items)) {
            this.items = {};
        }
    }
    /**
     * Gets an item from the dictionary.
     *
     * @param {string} key The key of the item.
     * @return {object} Returns an item if found, else returns null.
     */
    Dictionary.prototype.get = function (key) {
        if (!this.contains(key)) {
            return null;
        }
        return this.items[key];
    };
    /**
     * Adds an item into the dictionary.
     * If the key already exists, then it will throw.
     *
     * @param {string} key The key of the item.
     * @param {object} value The item to be added.
     * @return {object} Returns the added item.
     */
    Dictionary.prototype.add = function (key, value) {
        if (this.contains(key)) {
            throw new Error("Key: " + key + " already exists.");
        }
        return this.insert(key, value);
    };
    ;
    /**
     * Inserts an item into the dictionary.
     * If an item already exists with the same key, it will be overridden by the new value.
     *
     * @param {string} key The key of the item.
     * @param {object} value The item to be added.
     * @return {object} Returns the added item.
     */
    Dictionary.prototype.insert = function (key, value) {
        if (key == null) {
            throw new Error('Key cannot be null or undefined');
        }
        this.items[key] = value;
        return value;
    };
    /**
     * Removes an item from the dictionary.
     * Will throw if the key doesn't exist.
     *
     * @param {string} key The key of the item.
     * @return {object} Returns the deleted item.
     */
    Dictionary.prototype.remove = function (key) {
        if (!this.contains(key)) {
            throw new Error("Key: " + key + " not found.");
        }
        var value = this.items[key];
        delete this.items[key];
        return value;
    };
    ;
    /**
     * Clears the dictionary.
     */
    Dictionary.prototype.clear = function () {
        this.items = {};
    };
    /**
     * Check if the dictionary contains the given key.
     *
     * @param {string} key The key of the item.
     * @return {boolean} Returns true if the key was found.
     */
    Dictionary.prototype.contains = function (key) {
        if (key == null) {
            throw new Error('Key cannot be null or undefined');
        }
        return this.items.hasOwnProperty(key);
    };
    /**
     * Lists all the keys in the dictionary.
     *
     * @return {array} Returns all the keys.
     */
    Dictionary.prototype.keys = function () {
        if (this.items == null) {
            return [];
        }
        return Object.keys(this.items);
    };
    /**
     * Lists all the values in the dictionary.
     *
     * @return {array} Returns all the values.
     */
    Dictionary.prototype.values = function () {
        var _this = this;
        return this.keys().map(function (key) { return _this.items[key]; });
    };
    /**
     * Get the dictionary.
     *
     * @return {object} Returns the dictionary if it contains data, null otherwise.
     */
    Dictionary.prototype.lookup = function () {
        return this.keys().length ? JSON.parse(JSON.stringify(this.items)) : null;
    };
    Object.defineProperty(Dictionary.prototype, "count", {
        /**
         * Number of items in the dictionary.
         *
         * @return {number} Returns the number of items in the dictionary.
         */
        get: function () {
            return this.keys().length;
        },
        enumerable: true,
        configurable: true
    });
    ;
    return Dictionary;
}());
exports.Dictionary = Dictionary;

},{}],8:[function(require,module,exports){
// Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license.
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var dictionary_1 = require("./dictionary");
var utilities_1 = require("./utilities");
var StorageType;
(function (StorageType) {
    StorageType[StorageType["LocalStorage"] = 0] = "LocalStorage";
    StorageType[StorageType["SessionStorage"] = 1] = "SessionStorage";
})(StorageType = exports.StorageType || (exports.StorageType = {}));
/**
 * Helper for creating and querying Local Storage or Session Storage.
 * @see Uses {@link Dictionary} to create an in-memory copy of
 * the storage for faster reads. Writes update the actual storage.
 */
var Storage = (function (_super) {
    __extends(Storage, _super);
    /**
     * @constructor
     * @param {string} container Container name to be created in the LocalStorage.
     * @param {StorageType} type[optional] Storage Type to be used, defaults to Local Storage.
    */
    function Storage(container, type) {
        var _this = _super.call(this) || this;
        _this.container = container;
        _this._storage = null;
        _this._notifyObservers = function (event) { return Storage._observers.forEach(function (observer) { return observer(event); }); };
        type = type || StorageType.LocalStorage;
        _this.switchStorage(type);
        _this._registerStorageEvent();
        return _this;
    }
    /**
     * Switch the storage type.
     * Switches the storage type and then reloads the in-memory collection.
     *
     * @type {StorageType} type The desired storage to be used.
     */
    Storage.prototype.switchStorage = function (type) {
        this._storage = type === StorageType.LocalStorage ? localStorage : sessionStorage;
        if (!this._storage.hasOwnProperty(this.container)) {
            this._storage[this.container] = null;
        }
        this.load();
    };
    /**
     * Add an item.
     * Extends Dictionary's implementation of add, with a save to the storage.
     */
    Storage.prototype.add = function (item, value) {
        this.load();
        _super.prototype.add.call(this, item, value);
        this.save();
        return value;
    };
    /**
     * Add or Update an item.
     * Extends Dictionary's implementation of insert, with a save to the storage.
     */
    Storage.prototype.insert = function (item, value) {
        this.load();
        _super.prototype.insert.call(this, item, value);
        this.save();
        return value;
    };
    /**
     * Remove an item.
     * Extends Dictionary's implementation with a save to the storage.
     */
    Storage.prototype.remove = function (item) {
        this.load();
        var value = _super.prototype.remove.call(this, item);
        this.save();
        return value;
    };
    /**
     * Clear the storage.
     * Extends Dictionary's implementation with a save to the storage.
     */
    Storage.prototype.clear = function () {
        _super.prototype.clear.call(this);
        this._storage.removeItem(this.container);
    };
    /**
     * Clear all storages.
     * Completely clears both the localStorage and sessionStorage.
     */
    Storage.clearAll = function () {
        window.localStorage.clear();
        window.sessionStorage.clear();
    };
    /**
     * Saves the current state to the storage.
     */
    Storage.prototype.save = function () {
        this._storage.setItem(this.container, JSON.stringify(this.items));
    };
    /**
     * Refreshes the storage with the current localStorage values.
     */
    Storage.prototype.load = function () {
        var items = JSON.parse(this._storage.getItem(this.container));
        this.items = utilities_1.Utilities.extend({}, this.items, items);
    };
    /**
     * Registers an event handler for the window.storage event and
     * triggers the observer when the storage event is fired.
     *
     * The window.storage event is registered only once.
     */
    Storage.prototype.onStorage = function (observer) {
        Storage._observers.push(observer);
    };
    Storage.prototype._registerStorageEvent = function () {
        var _this = this;
        this.onStorage(function (event) { return _this.load(); });
        if (Storage._storageEventRegistered) {
            return;
        }
        window.onstorage = function (event) { return _this._notifyObservers(event); };
        Storage._storageEventRegistered = true;
    };
    return Storage;
}(dictionary_1.Dictionary));
Storage._observers = [];
exports.Storage = Storage;

},{"./dictionary":7,"./utilities":9}],9:[function(require,module,exports){
// Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license.
"use strict";
/**
 * Constant strings for the host types
 */
exports.HostType = {
    WEB: 'WEB',
    ACCESS: 'ACCESS',
    EXCEL: 'EXCEL',
    ONENOTE: 'ONENOTE',
    OUTLOOK: 'OUTLOOK',
    POWERPOINT: 'POWERPOINT',
    PROJECT: 'PROJECT',
    WORD: 'WORD'
};
/**
 * Constant strings for the host platforms
 */
exports.PlatformType = {
    IOS: 'IOS',
    MAC: 'MAC',
    OFFICE_ONLINE: 'OFFICE_ONLINE',
    PC: 'PC'
};
/*
* Retrieves host info using a workaround that utilizes the internals of the
* Office.js library. Such workarounds should be avoided, as they can lead to
* a break in behavior, if the internals are ever changed. In this case, however,
* Office.js will soon be delivering a new API to provide the host and platform
* information.
*/
function getHostInfo() {
    var host = 'WEB';
    var platform = null;
    var extras = null;
    try {
        if (window.sessionStorage == null) {
            throw new Error("Session Storage isn't supported");
        }
        var hostInfoValue = window.sessionStorage['hostInfoValue'];
        _a = hostInfoValue.split('$'), host = _a[0], platform = _a[1], extras = _a[2];
        // Older hosts used "|", so check for that as well:
        if (extras == null) {
            _b = hostInfoValue.split('|'), host = _b[0], platform = _b[1];
        }
        host = host.toUpperCase() || 'WEB';
        platform = platform.toUpperCase() || null;
    }
    catch (error) {
    }
    return { host: host, platform: platform };
    var _a, _b;
}
;
/**
 * Helper exposing useful Utilities for Office-Addins.
 */
var Utilities = (function () {
    function Utilities() {
    }
    // Underscore.js implementation of extend.
    // https://github.com/jashkenas/underscore/blob/master/underscore.js
    /**
     * Utility to clone or merge objects.
     */
    Utilities.extend = function (dest) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        var length = arguments.length;
        if (length < 2 || dest == null) {
            return dest; // if there are no objects to extend then return the current object
        }
        if (sources) {
            dest = Object(dest); // create a new object to extend if there are any extensions
        }
        for (var index = 1; index < length; index++) {
            var source = arguments[index]; // foreach object
            if (source == null) {
                continue; // move on if the object is null or undefined
            }
            var keys = Object.keys(source), // get all the keys
            l = keys.length; // cache the length
            for (var i = 0; i < l; i++) {
                var key = keys[i]; // for each key
                if (!sources || dest[key] === void 0) {
                    dest[key] = source[key]; // replace values
                }
            }
        }
        return dest;
    };
    ;
    Object.defineProperty(Utilities, "host", {
        /*
         * Returns the current host which is either the name of the application where the
         * Office Add-in is running ("EXCEL", "WORD", etc.) or simply "WEB" for all other platforms.
         * The property is always returned in ALL_CAPS.
         * Note that this property is guranteed to return the correct value ONLY after Office has
         * initialized (i.e., inside, or seqentially after, an Office.initialize = function() { ... }; statement).
         *
         * This code currently uses a workaround that relies on the internals of Office.js.
         * A more robust approach is forthcoming within the official  Office.js library.
         * Once the new approach is released, this implementation will switch to using it
         * instead of the current workaround.
         */
        get: function () {
            var hostInfo = getHostInfo();
            return exports.HostType[hostInfo.host];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Utilities, "platform", {
        /*
        * Returns the host application's platform ("IOS", "MAC", "OFFICE_ONLINE", or "PC").
        * This is only valid for Office Add-ins, and hence returns null if the HostType is WEB.
        * The platform is in ALL-CAPS.
        * Note that this property is guranteed to return the correct value ONLY after Office has
        * initialized (i.e., inside, or seqentially after, an Office.initialize = function() { ... }; statement).
        *
        * This code currently uses a workaround that relies on the internals of Office.js.
        * A more robust approach is forthcoming within the official  Office.js library.
        * Once the new approach is released, this implementation will switch to using it
        * instead of the current workaround.
        */
        get: function () {
            var hostInfo = getHostInfo();
            if (Utilities.host === exports.HostType.WEB) {
                return null;
            }
            var platforms = {
                'IOS': exports.PlatformType.IOS,
                'MAC': exports.PlatformType.MAC,
                'WEB': exports.PlatformType.OFFICE_ONLINE,
                'WIN32': exports.PlatformType.PC
            };
            return platforms[hostInfo.platform] || null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Utilities, "isAddin", {
        /**
         * Utility to check if the code is running inside of an add-in.
         */
        get: function () {
            return Utilities.host !== exports.HostType.WEB;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Utility to print prettified errors.
     */
    Utilities.log = function (exception) {
        if (exception == null) {
            console.error(exception);
        }
        else if (typeof exception === 'string') {
            console.error(exception);
        }
        else {
            console.group(exception.message || exception.name || 'Unhandled Exception');
            console.error(exception);
            if ((exception.stack == null)) {
                console.groupCollapsed('Stack Trace');
                console.error(exception.stack);
                console.groupEnd();
            }
            if (window.OfficeExtenstion && exception instanceof OfficeExtension.Error) {
                console.groupCollapsed('Debug Info');
                console.error(exception.debugInfo);
                console.groupEnd();
            }
            console.groupEnd();
        }
    };
    return Utilities;
}());
exports.Utilities = Utilities;

},{}],"office-js-helpers":[function(require,module,exports){
// Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license.
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
__export(require("./errors/dialog"));
__export(require("./errors/auth"));
__export(require("./helpers/dialog"));
__export(require("./helpers/utilities"));
__export(require("./helpers/dictionary"));
__export(require("./helpers/storage"));
__export(require("./helpers/dialog"));
__export(require("./authentication/token.manager"));
__export(require("./authentication/endpoint.manager"));
__export(require("./authentication/authenticator"));

},{"./authentication/authenticator":1,"./authentication/endpoint.manager":2,"./authentication/token.manager":3,"./errors/auth":4,"./errors/dialog":5,"./helpers/dialog":6,"./helpers/dictionary":7,"./helpers/storage":8,"./helpers/utilities":9}]},{},[])("office-js-helpers")
});